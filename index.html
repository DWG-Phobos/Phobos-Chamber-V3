<html>
	<head>
		<title>Phobos: Answer or Die</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src='js/OrbitControls.js'></script>
		<script src='js/ColladaLoader.js'></script>
		<script src='js/jquery-1.10.2.min.js'></script>
		<script src='js/keyboard.js'></script>
		<script>
			
			var scene = new THREE.Scene(); // Escena
						
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.5, 1000 );	
			camera.rotation.x = -25 * Math.PI / 180;

			
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );	// Tamany de la pantalla de renderitzat
			document.body.appendChild( renderer.domElement );	// Coloquem el render al document web
			

			//Free camera: uncoment to freely navigate the zone
			//var controls = new THREE.OrbitControls(camera);

			//Charge Model
			var loadingManager = new THREE.LoadingManager( function() {

			scene.add( player );
			
			} );
			
			var loader = new THREE.ColladaLoader( loadingManager );
			var clock = new THREE.Clock(),
			mixer;
			var keyboard = new THREEx.KeyboardState();
			var actions = [];
			var sceneAnimation;

			loader.options.convertUpAxis = true;
			loader.load( 'models/Hero_alter/Hero.dae', function ( collada ) {
				
				player = collada.scene;
				player.scale.set(0.03,0.03,0.03);
				
				var sceneAnimationClip = collada.animations[ 0 ];
				mixer = new THREE.AnimationMixer(player);
				
				var idle = THREE.AnimationUtils.subclip( sceneAnimationClip, 'idle', 0, 89  )
				var run = THREE.AnimationUtils.subclip( sceneAnimationClip, 'run', 90, 110  )
				
				actions.push(mixer.clipAction(idle));
				actions.push(mixer.clipAction(run));

				sceneAnimation = actions[0];
				sceneAnimation.play();
			} );
			
			var ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
            scene.add( ambientLight );

            var light1 = new THREE.PointLight( 0xcc0000, 0.4, 100 );
            light1.position.set( 10, 0, 20 );
            scene.add( light1 );

            var light2 = new THREE.PointLight( 0x00cc00, 0.4, 100 );
            light2.position.set( 0, 0, 20 );
            scene.add( light2 );

            var light3 = new THREE.PointLight( 0x0000cc, 0.4, 100 );
            light3.position.set( -10, 0, 10 );
            scene.add( light3 );
			
			var lightX = new THREE.PointLight( 0x00ff00, 0.7, 15 );
            lightX.position.set( 0, 0, 0 );
            scene.add( lightX );


			var mesh = new THREE.Object3D();
			
			//Creating Obstacles

				//Creating Cubes
				var largeCubeGeometry = new THREE.BoxGeometry( 5, 2, 1 ); //Crear Geometria
				var halfGiantGeometry = new THREE.BoxGeometry(9, 2.5, 5);
				var cubeGeometry = new THREE.BoxGeometry( 1, 1, 1 ); //Crear Geometria
				var tallCubeGeometry = new THREE.BoxGeometry( 1, 2, 1 ); //Crear Geometria
				var giantGeometry = new THREE.BoxGeometry(9,5,10);
				var platformGeometry = new THREE.BoxGeometry(2,1,2);
				

				var texture2 = THREE.ImageUtils.loadTexture('metal_floor.jpg');
				texture2.wrapS = THREE.RepeatWrapping;
				texture2.wrapT = THREE.RepeatWrapping;
				texture2.repeat.set(1, 1);
				var material2 = new THREE.MeshBasicMaterial({map: texture2});


			
				//LARGE CUBE TEXTURE CREATION
				
				var cubeTextures = [

					THREE.ImageUtils.loadTexture('hazard.jpeg'), //RIGHT SIDE
					THREE.ImageUtils.loadTexture('hazard.jpeg'), //LEFT SIDE
					THREE.ImageUtils.loadTexture('hazard.jpeg'), //TOP SIDE
					THREE.ImageUtils.loadTexture('hazard.jpeg'), //BOTTOM SIDE
					THREE.ImageUtils.loadTexture('hazard.jpeg'), //FRONT SIDE
					THREE.ImageUtils.loadTexture('hazard.jpeg') //BACK SIDE
				];

				
				var cubeFacesSizes = [

					[1,2],
					[1,3],
					[1,5],
					[1,6],
					[1,1],
					[0.5,0.5]
				];

				for (i = 0; i < cubeFacesSizes.length; i++) { 
    				
    				cubeTextures[i].wrapS = THREE.RepeatWrapping;
					cubeTextures[i].wrapT = THREE.RepeatWrapping;
					cubeTextures[i].repeat.set(cubeFacesSizes[i][0],cubeFacesSizes[i][1]);
					
				} 

				//MATERIAL CREATION
				
				var cubeMaterials = [
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[0]
			       }),
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[1]
			       }),
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[2]
			       }),
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[3]
			       }),
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[4]
			       }),
			       new THREE.MeshBasicMaterial({
			           map: cubeTextures[5]
			       })
			    ];
			 
				var texture = THREE.ImageUtils.loadTexture('hazard.jpeg');
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(1, 1);
				var material = new THREE.MeshBasicMaterial({map: texture});

				var largeCube1 = new THREE.Mesh( largeCubeGeometry, cubeMaterials ); //Crear objecte
				var largeCube2 = new THREE.Mesh( largeCubeGeometry, material ); //Crear objecte
				var largeCube3 = new THREE.Mesh( largeCubeGeometry, material ); //Crear objecte
				var largeCube4 = new THREE.Mesh( largeCubeGeometry, material ); //Crear objecte
				var largeCube5 = new THREE.Mesh( largeCubeGeometry, material ); //Crear objecte
				var cube1 = new THREE.Mesh( cubeGeometry, material ); //Crear objecte
				var cube2 = new THREE.Mesh( cubeGeometry, material ); //Crear objecte
				var tallCube = new THREE.Mesh( tallCubeGeometry, material ); //Crear objecte
				var giantCube = new THREE.Mesh( giantGeometry, material ); //Crear objecte
				var giantCube2 = new THREE.Mesh( giantGeometry, material ); //Crear objecte
				var platform = new THREE.Mesh( platformGeometry, material);
				var platform2 = new THREE.Mesh( platformGeometry, material);
				var step1 = new THREE.Mesh( halfGiantGeometry, material );
				//Cubes values
				cube1.position.set(-0.5, 2.5, -30);
				cube2.position.set(-2, 0.5, -31);
				tallCube.position.set(0.5, 3, -30);
				largeCube1.position.set(-5, 1, -10);
				largeCube2.position.set(-7.5, 1, -20);
				largeCube3.position.set(-1.5, 1, -30);
				largeCube4.position.set(-5, 1, -40);
				largeCube5.position.set(-7.5, 1, -50);
				giantCube.position.set(5.5, 2.5, -11);
				giantCube2.position.set(5.5, 2.5, -30);
				platform.position.set(2, 4.5, -19);
				platform2.position.set(5, 4.5, -22);
				step1.position.set(5.5, 1.2, -37.5)
				//Adding Cubes to the Mesh
				
				//Creating Triangles
				var geometry = new THREE.Geometry();

			    geometry.vertices = [
			        new THREE.Vector3( 1, 0, -1 ),
			        new THREE.Vector3( 10, 0, -1 ),
			        new THREE.Vector3( 1, 0, -6 ),
			        new THREE.Vector3( 10, 0, -6 ),
			        new THREE.Vector3( 1, 5, -6 ),
			        new THREE.Vector3( 10, 5, -6 )
			    ];
			    
			    geometry.faces = [
			        new THREE.Face3( 1, 0, 2),
			        new THREE.Face3( 2, 3, 1),
			        new THREE.Face3( 2, 0, 4),
			        new THREE.Face3( 3, 5, 1),
			        new THREE.Face3( 1, 4, 0),
			        new THREE.Face3( 4, 1, 5),
			        new THREE.Face3( 5, 5, 2,),
			        new THREE.Face3( 3, 2, 5,)
			    ];
				
			    var triangle = new THREE.Mesh( geometry, material);
			    mesh.add(triangle);
			
			//Creating World	

				//Creating the ground
				var groundGeometry = new THREE.PlaneGeometry(20, 800);
				var roofGeometry = new THREE.PlaneGeometry(20, 800);
				var material1 = new THREE.MeshBasicMaterial( { color: "red" } ); //Crear color

				//var materialGround = new THREE.MeshBasicMaterial( {color: 0xaa3f39});

				var groundTexture = THREE.ImageUtils.loadTexture('neon_floor.jpg');

				groundTexture.wrapS = THREE.RepeatWrapping;
				groundTexture.wrapT = THREE.RepeatWrapping;
				groundTexture.repeat.set(1, 40);
				var materialGround = new THREE.MeshBasicMaterial({map: groundTexture});

				var roofTexture = THREE.ImageUtils.loadTexture('metal.jpg');

				roofTexture.wrapS = THREE.RepeatWrapping;
				roofTexture.wrapT = THREE.RepeatWrapping;
				roofTexture.repeat.set(1, 40);
				var materialRoof = new THREE.MeshBasicMaterial({map: roofTexture});

				var ground = new THREE.Mesh(groundGeometry, materialGround);
				var roof = new THREE.Mesh(roofGeometry, materialRoof);

				//Creating the walls
				var wallGeometry = new THREE.PlaneGeometry(800, 20);
				
				//var wallMaterial = new THREE.MeshBasicMaterial( { color: "blue" } ); //Crear color

				var wallTexture = THREE.ImageUtils.loadTexture('metal.jpg');
				wallTexture.wrapS = THREE.RepeatWrapping;
				wallTexture.wrapT = THREE.RepeatWrapping;
				wallTexture.repeat.set(20, 1);
        		var wallMaterial = new THREE.MeshBasicMaterial({map: wallTexture});

				var rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
				var leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
				
				//Ground values
				//ground.position.y = 30;
				ground.rotation.x = -Math.PI / 2;
				roof.rotation.x = Math.PI / 2;
				roof.position.y = 20;

				//Right Wall Values
				rightWall.position.x = 10;
				rightWall.position.y = 10;
				rightWall.position.z = 5;
				
				rightWall.rotation.y = -Math.PI / 2;

				//Left Wall Values

				leftWall.position.x = -10;
				leftWall.position.y = 10;
				leftWall.position.z = 5;

				leftWall.rotation.y = Math.PI / 2;

				mesh.add(roof);
				mesh.add(ground);

				var obstacles = [
					cube1,
					cube2,
					largeCube1,
					largeCube2,
					largeCube3,
					largeCube4,
					largeCube5,
					tallCube,
					giantCube,
					giantCube2,
					platform,
					platform2,
					step1,
					leftWall,
					rightWall

                ]

                for (i = 0; i < obstacles.length; i += 1) {
		           
		            mesh.add(obstacles[i]);
		        }
				
			//Create answers
                var answerBoxGeometry = new THREE.BoxGeometry(5,0.5,5);

                var textureA = THREE.ImageUtils.loadTexture('1.jpg');
				textureA.wrapS = THREE.RepeatWrapping;
				textureA.wrapT = THREE.RepeatWrapping;
				textureA.repeat.set(1, 1);

				var textureB = THREE.ImageUtils.loadTexture('2.jpg');
				textureB.wrapS = THREE.RepeatWrapping;
				textureB.wrapT = THREE.RepeatWrapping;
				textureB.repeat.set(1, 1);

				var textureC = THREE.ImageUtils.loadTexture('3.jpg');
				textureC.wrapS = THREE.RepeatWrapping;
				textureC.wrapT = THREE.RepeatWrapping;
				textureC.repeat.set(1, 1);

				var textureD = THREE.ImageUtils.loadTexture('4.jpg');
				textureD.wrapS = THREE.RepeatWrapping;
				textureD.wrapT = THREE.RepeatWrapping;
				textureD.repeat.set(1, 1);

                var materialA = new THREE.MeshBasicMaterial( { map: textureA } ); //Crear color
                var materialB = new THREE.MeshBasicMaterial( { map: textureB } ); //Crear color
                var materialC = new THREE.MeshBasicMaterial( { map: textureC } ); //Crear color
                var materialD = new THREE.MeshBasicMaterial( { map: textureD } ); //Crear color

                var answerBoxA = new THREE.Mesh( answerBoxGeometry, materialA);
                var answerBoxB = new THREE.Mesh( answerBoxGeometry, materialB);
                var answerBoxC = new THREE.Mesh( answerBoxGeometry, materialC);
                var answerBoxD = new THREE.Mesh( answerBoxGeometry, materialD);

                answerBoxA.position.set(-7.5, 0.25, -60);
                answerBoxB.position.set(-2.5, 0.25, -60);
                answerBoxC.position.set(2.5, 0.25, -60);
                answerBoxD.position.set(7.5, 0.25, -60);

                mesh.add(answerBoxA);
                mesh.add(answerBoxB);
                mesh.add(answerBoxC);
                mesh.add(answerBoxD);
			

			//Adding all objects to the Scene
			scene.add(mesh);

			//Function that renders the scene
			var animate = function () {

				requestAnimationFrame( animate );
				update();

				renderer.render(scene, camera);
			};

			//Col·lisions **********************************
			var caster = new THREE.Raycaster();
			var dummy = new THREE.Object3D();
			var distance = 3;

			function update()
			{
			// delta = change in time since last call (seconds)
			var delta = clock.getDelta();
			var moveDistance = 10 * delta;
			walking = false;
			var lastAction = sceneAnimation;
			if ( keyboard.pressed("down") || keyboard.pressed("up")){
				if (lastAction == actions[0]){
					sceneAnimation = actions[1];
					lastAction.stop();
					sceneAnimation.fadeIn(0.2).play();
				}
			}
			else{
				if (lastAction == actions[1]){
					sceneAnimation = actions[0];
					lastAction.stop();
					sceneAnimation.fadeIn(0.2).play();
				}
			}
			//Detector de col·lisions ***************************************************************************************************************
			dummy.position.x = player.position.x
			dummy.position.y = player.position.y
			dummy.position.z = player.position.z
			
			dummy.rotation.x = player.rotation.x
			dummy.rotation.y = player.rotation.y
			dummy.rotation.z = player.rotation.z
			
			if ( keyboard.pressed("down") )
				dummy.translateZ( moveDistance )
			if ( keyboard.pressed("up") )
				dummy.translateZ( -moveDistance );
			
			direccio = new  THREE.Vector3(dummy.position.x, dummy.position.y, dummy.position.z)
			
            caster.set(dummy.position, direccio);
            var collisions = caster.intersectObjects(obstacles);
           
            if (!(collisions.length > 0 && collisions[0].distance <= distance)) {
			
				if ( keyboard.pressed("down") )
					player.translateZ( moveDistance )
				if ( keyboard.pressed("up") )
					player.translateZ( -moveDistance );

	        }
;
			

			
	        if ( keyboard.pressed("left") )
				player.rotation.y += delta;
				
			if ( keyboard.pressed("right") )
				player.rotation.y -= delta;	
				
				var walkingKeys = ["up", "down", "left", "right"];
				for (var i = 0; i < walkingKeys.length; i++)
				{
					if ( keyboard.pressed(walkingKeys[i]) )
						walking = true;
				}

	         

	       
			
			camera.position.set(0,
				player.position.y + 12,
				player.position.z + 15);
			
			if( mixer ) {
				mixer.update( delta );
			}
		}
			
			animate();

		</script>
	</body>
</html>
